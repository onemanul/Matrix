# Matrix (#1)

## Описание

Данная библиотека реализует классы для работы с векторами и матрицами в языке C++. Она предоставляет набор функций для выполнения различных математических операций, (сложение, умножение, транспонирование, нахождение норм, решение систем линейных алгебраических уравнений (СЛАУ) различными методами и др.).

## Структура библиотеки

### Класс `vctr`:

- **Конструкторы**:
  - `vctr()`: Создает вектор по умолчанию (строка).
  - `vctr(bool row)`: Создает вектор, задавая его ориентацию (строка или столбец).
  - `vctr(vector<double> v)`: Создает вектор из заданного вектора значений (строка).
  - `vctr(vector<double> v, bool row)`: Создает вектор из заданного вектора значений с указанием ориентации.
 
- **Методы**:
  - `void trans()`: Транспонирует вектор (меняет его ориентацию).
  - Нормы:
    - `double norm_first()`;
    - `double norm_second()`;
    - `double norm_infinity()`.
  - Операции: `transpos`, `+`, `-`, `*` (на число), `/` (на число), `*` (скалярное произведение), `==`, `<<` (вывод).
 
---
---

### Класс `Matrix`:

- **Конструкторы**:
  - `Matrix()`: Создает матрицу 1x1, инициализированную нулем.
  - `Matrix(size_t n)`: Создает квадратную матрицу n x n, инициализированную нулями.
  - `Matrix(size_t rows, size_t cols)`: Создает матрицу с заданным количеством строк и столбцов.
  - `Matrix(vector<vector<double>> dt)`: Создает матрицу из заданного двумерного вектора.
  - `Matrix(vctr v)`: Создает матрицу из вектора.

- **Статические методы**:
  - `static Matrix unit_matr(size_t n)`: Создает единичную матрицу размером n x n.
  - `static Matrix rand_matr(size_t rows, size_t cols)`: Создает матрицу заданного размера с случайными значениями.

- **Методы**:
  - `size_t getRows() const`: Возвращает количество строк в матрице.
  - `size_t getCols() const`: Возвращает количество столбцов в матрице.
  - `double& operator()(size_t row, size_t col)`: Обращение к элементам матрицы.
  - `vctr to_vector()`: Преобразует матрицу в вектор.
  - Изменение матрицы:
    - `void changeRow(size_t r)`: Изменяет количество строк в матрице.
    - `void changeCol(size_t c)`: Изменяет количество столбцов в матрице.
    - `void swap_rows(size_t a, size_t b)`: Меняет местами строки a и b.
  - Проверка условий:
    - `bool is_symmetry()`: Проверяет, является ли матрица симметричной.
    - `bool is_positive_definite()`: Проверяет, является ли матрица положительно определенной.
    - `bool is_tridiagonal()`: Проверяет, является ли матрица тридиагональной.
  - Нормы:
    - `double norm_first()`: Вычисляет 1-норму.
    - `double norm_infinity()`: Вычисляет бесконечную норму.
    - `double norm_evkl()`: Вычисляет евклидову норму.
  - Определитель:
    - `double determinant()`: Вычисляет определитель матрицы.
    - `double determinant_with_LU()`: Вычисляет определитель с помощью LU-разложения.
  - Нахождение иных матриц:
    - `bool find_LU_matrix(Matrix& L, Matrix& U)`: Находит LU-разложение матрицы.
    - `bool find_QR_matrix(Matrix& Q, Matrix& R)`: Находит QR-разложение матрицы.
    - `bool find_P_matrix(Matrix& P)`: Находит матрицу перестановок.
    - `bool find_L_Lt_matrix(Matrix& L, Matrix& L_t)`: Находит матрицы L и L^T для метода Холецкого.
 
- **Дружественные функции**:
  - Возвращаемый объект: `Matrix`; исходная матрица не изменяется:
    - `inverse(Matrix& m)`: Обратная матрица.
    - `transpos(Matrix& m)`: Транспонированная матрица.
  - Решение СЛАУ, возвращаемый объект: `vctr`. Аргумент `mtr` принимает матрицу размером $n \times n+1$, в остальных случаях принимаются квадратные матрицы.
    - `SLAE(Matrix& mtr)`: Решение СЛАУ, поиск главного элемента по строкам.
    - `SLAE(Matrix& mtr, int metod)`: Решение СЛАУ с выбором метода поиска главного элемента (0 - по строкам, 1 - по столбцам, 2 - по строкам и столбцам).
    - `SLAE_LU(Matrix& A, vctr& b)`: Решение СЛАУ с помощью LU разложения.
    - `SLAE_LU(Matrix& L, Matrix& U, vctr& b)`: Решение СЛАУ с помощью LU разложения.
    - `SLAE_LUP(Matrix& A, vctr& b)`: Решение СЛАУ с помощью LUP разложения.
    - `SLAE_Cholesky(Matrix& A, vctr& b)`: Решение СЛАУ методом Холецкого.
    - `SLAE_Cholesky(Matrix& L, Matrix& L_t, vctr& b)`: Решение СЛАУ методом Холецкого.
    - `SLAE_Tomas(Matrix& A, vctr& b)`: Решение СЛАУ для тридиагональных матриц методом Томаса (прогонки).
    - `SLAE_QR(Matrix& A, vctr& b)`: Решение СЛАУ с помощью QR разложения.
    - `SLAE_QR(Matrix& Q, Matrix& R, vctr& b)`: Решение СЛАУ с помощью QR разложения.
    - `SLAE_Iteration(Matrix& A, vctr& b, double accuracy, vctr& initial_approximation)`: Решение СЛАУ методом простой итерации c заданной точностью и начальным приближением.
    - `SLAE_Seidel(Matrix& A, vctr& b, double accuracy, vctr& initial_approximation)`: Решение СЛАУ методом Зейделя c заданной точностью и начальным приближением.
  - Нахождение собственных чисел:
    - `double power_law_method(Matrix& A, double accuracy, vctr& x_next)`: Находит собственное значение с максимальной абсолютной величиной.
    - `double power_law_method_with_normalization(Matrix& A, double accuracy, vctr& x_next)`: Находит собственное значение с максимальной абсолютной величиной с нормализацией.
   
- **Операторы**:
  - `*`: Умножение матрицы на скаляр.
  - `*`: Умножение вектора на матрицу (слева и справа).
  - `+`: Сложение матриц.
  - `-`: Вычитание матриц.
  - `*`: Умножение двух матриц.
  - `==`: Проверка на равенство двух матриц.
  - `<<`: Вывод матрицы в поток.
  - `+(Matrix& m, vctr& v)`: Добавляет вектор к матрице (строку или столбец), увеличивая её размерность.
